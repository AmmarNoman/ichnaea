"""Functionality related to statsd, sentry and freeform logging."""
from collections import deque
import logging
import logging.config
import time

import markus
from pyramid.httpexceptions import HTTPException, HTTPClientError, HTTPRedirection
from raven import Client as RavenClient
from raven.transport.gevent import GeventedHTTPTransport
from raven.transport.http import HTTPTransport
from raven.transport.threaded import ThreadedHTTPTransport
import structlog

from ichnaea.conf import settings
from ichnaea.exceptions import BaseClientError
from ichnaea.util import version_info


METRICS = markus.get_metrics()


def configure_logging():
    """Configure Python logging."""
    local_dev_env = settings("local_dev_env")
    logging_level = settings("logging_level")

    if local_dev_env:
        handlers = ["dev"]
        # Prepare structlog logs for local dev ProcessorFormatter
        structlog_fmt_prep = structlog.stdlib.ProcessorFormatter.wrap_for_formatter
        structlog_dev_processors = [
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
        ]
    else:
        handlers = ["mozlog"]
        # Prepare structlog logs for JsonLogFormatter
        structlog_fmt_prep = structlog.stdlib.render_to_log_kwargs
        structlog_dev_processors = []

    # Processors used for logs generated by structlog and stdlib's logging
    logging_config = {
        "version": 1,
        "disable_existing_loggers": True,
        "formatters": {
            "structlog_dev_console": {
                "()": structlog.stdlib.ProcessorFormatter,
                "processor": structlog.dev.ConsoleRenderer(colors=True),
                "foreign_pre_chain": structlog_dev_processors,
            },
            "mozlog_json": {
                "()": "dockerflow.logging.JsonLogFormatter",
                "logger_name": "ichnaea",
            },
        },
        "handlers": {
            "dev": {
                "class": "logging.StreamHandler",
                "formatter": "structlog_dev_console",
                "level": "DEBUG",
            },
            "mozlog": {
                "class": "logging.StreamHandler",
                "formatter": "mozlog_json",
                "level": "DEBUG",
            },
        },
        "loggers": {
            "alembic": {
                "propagate": False,
                "handlers": handlers,
                "level": logging_level,
            },
            "celery": {
                "propagate": False,
                "handlers": handlers,
                "level": logging_level,
            },
            "ichnaea": {
                "propagate": False,
                "handlers": handlers,
                "level": logging_level,
            },
            "markus": {
                "propagate": False,
                "handlers": handlers,
                "level": logging_level,
            },
            # https://stripe.com/blog/canonical-log-lines
            "canonical-log-line": {
                "propagate": False,
                "handlers": handlers,
                "level": logging_level,
            },
        },
        "root": {"handlers": handlers, "level": "WARNING"},
    }

    logging.config.dictConfig(logging_config)

    structlog_processors = (
        [structlog.threadlocal.merge_threadlocal, structlog.stdlib.filter_by_level]
        + structlog_dev_processors
        + [
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog_fmt_prep,
        ]
    )
    structlog.configure(
        context_class=structlog.threadlocal.wrap_dict(dict),
        processors=structlog_processors,
        logger_factory=structlog.stdlib.LoggerFactory(
            ignore_frame_names=["venusian", "pyramid.config"]
        ),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )


RAVEN_TRANSPORTS = {
    # Used in the webapp
    "gevent": GeventedHTTPTransport,
    # Used in the tests
    "sync": HTTPTransport,
    # Used in celery
    "threaded": ThreadedHTTPTransport,
}


def configure_raven(transport=None, _client=None):
    """Configure and return a :class:`raven.Client` instance.

    :param transport: The transport to use, one of the
                      :data:`RAVEN_TRANSPORTS` keys.
    :param _client: Test-only hook to provide a pre-configured client.
    """
    if _client is not None:
        return _client

    transport = RAVEN_TRANSPORTS.get(transport)
    if not transport:
        raise ValueError("No valid raven transport was configured.")

    dsn = settings("sentry_dsn")
    klass = DebugRavenClient if not dsn else RavenClient
    info = version_info()
    release = info.get("version") or info.get("commit") or "unknown"
    client = klass(dsn=dsn, transport=transport, release=release)
    return client


def configure_stats():
    """Configure Markus for metrics."""
    local_dev_env = settings("local_dev_env")
    if local_dev_env:
        markus.configure(backends=[{"class": "markus.backends.logging.LoggingMetrics"}])
        return

    if settings("statsd_host"):
        markus.configure(
            backends=[
                {
                    "class": "markus.backends.datadog.DatadogMetrics",
                    "options": {
                        "statsd_host": settings("statsd_host"),
                        "statsd_port": settings("statsd_port"),
                        "statsd_namespace": "location",
                    },
                }
            ]
        )
    else:
        logging.getLogger(__name__).warning("STATSD_HOST not set; no statsd configured")


def log_tween_factory(handler, registry):
    """A logging tween, handling collection of stats, exceptions, and a request log."""

    def log_tween(request):
        structlog.threadlocal.clear_threadlocal()

        if request.path in registry.skip_logging or request.path.startswith("/static"):
            # shortcut handling for static assets
            try:
                return handler(request)
            except HTTPException:
                # don't capture exceptions for normal responses
                raise
            except Exception:
                registry.raven_client.captureException()
                raise

        start = time.time()
        statsd_tags = [
            # Convert a URI to a statsd acceptable metric name
            "path:%s" % request.path.replace("/", ".").lstrip(".").replace("@", "-"),
            "method:%s" % request.method.lower(),
        ]
        structlog.threadlocal.bind_threadlocal(
            http_method=request.method, http_path=request.path
        )

        def record_response(status_code):
            duration = time.time() - start
            duration_ms = int(round(duration * 1000))
            duration_s = round(duration, 3)

            METRICS.timing("request.timing", duration_ms, tags=statsd_tags)
            METRICS.incr("request", tags=statsd_tags + ["status:%s" % status_code])
            logger = structlog.get_logger("canonical-log-line")
            logger.info(
                f"{request.method} {request.path} - {status_code}",
                http_status=status_code,
                duration_s=duration_s,
            )

        try:
            response = handler(request)
            record_response(response.status_code)
            return response
        except (BaseClientError, HTTPRedirection) as exc:
            # don't capture exceptions
            record_response(exc.status_code)
            raise
        except HTTPClientError:
            # ignore general client side errors
            raise
        except Exception as exc:
            if isinstance(exc, HTTPException):
                status = exc.status_code
            else:
                status = 500
            record_response(status)
            registry.raven_client.captureException()
            raise

    return log_tween


class DebugRavenClient(RavenClient):
    """An in-memory raven client with an inspectable message queue."""

    def __init__(self, *args, **kw):
        super(DebugRavenClient, self).__init__(*args, **kw)
        self.msgs = deque(maxlen=100)

    def _clear(self):
        self.msgs.clear()
        self.context.clear()

    def is_enabled(self):
        return True

    def send(self, auth_header=None, **data):
        self.msgs.append(data)
        self._successful_send()

    def check(self, expected=()):
        """
        Checks the raven message stream looking for the expected messages.

        The expected argument should be a list of either names or tuples.

        If it is a tuple, it should be a tuple of name and an expected count.

        The names are matched via startswith against the captured exception
        messages.
        """
        messages = [msg["message"] for msg in self.msgs]
        matched_msgs = []
        for exp in expected:
            count = 1
            name = exp
            if isinstance(exp, tuple):
                name, count = exp
            matches = [msg for msg in self.msgs if msg["message"].startswith(name)]
            matched_msgs.extend(matches)
            assert len(matches) == count, messages

        for msg in matched_msgs:
            self.msgs.remove(msg)
